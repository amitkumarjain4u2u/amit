( function( window, $, rh, undefined ) {
    Drupal.behaviors.webux = {
        attach: function( context, settings ) {
            rh.webux = {};

            // jscs:disable validateIndentation

// Requires the utils.js file be included as well for breakpoint validation
if ( typeof rh.webux.utils === "undefined" ) {
    //--- Global utility variables
rh.webux.utils = {
    lg: function() {
        return $( window ).width() >= 1200;
    },
    md: function() {
        return $( window ).width() >= 992 && $( window ).width() < 1200;
    },
    sm: function() {
        return $( window ).width() >= 768 && $( window ).width() < 992;
    },
    xs: function() {
        return $( window ).width() >= 480 && $( window ).width() < 768;
    },
    xxs: function() {
        return $( window ).width() < 480;
    },
    isDesktop: $( window ).width >= 768,
    isTablet: $( window ).width >= 480 && $( window ).width < 768,
    isMobile: $( window ).width < 480,
    breakpoints: [ "xxs", "xs", "sm", "md", "lg" ],
    url: {
        root: window.location.hostname,
        path: window.location.pathname.split( "/" ).splice( 1 )
    },
    lang:   window.location.pathname.split( "/" ).splice( 1 )[ 0 ]
};

}

rh.webux.toggle = {
    attr: {
        openEvent: "data-ux-toggle-open",
        closeEvent: "data-ux-toggle-close-on",
        toggleID: "data-ux-toggle-id",
        toggleTarget: "data-ux-toggle-target",
        state: "data-ux-state",
        align: "data-ux-align-element",
        toggleSingle: "data-ux-toggle-single"
    },
    isAtBreakpoint: function( bpString ) {
        /* This function tests to see the current breakpoint exists in the
            allowed bp strings provided as input */
        var atBreakpoint = true;
        // If the breakpoint string exists and is not empty
        if ( typeof bpString !== "undefined" && bpString !== "" ) {
            // Test that our current breakpoint is in this list of support breakpoints
            var bps = bpString.split( " " );
            atBreakpoint = false;
            // If the first array value is not empty
            $.each( bps, function( idx, bp ) {
                // Check that the bp value is one of the supported breakpoints
                if ( $.inArray( bp, [ "xxs", "xs", "sm", "md", "lg" ] ) >= 0 ) {
                    if ( rh.webux.utils[ bp ]() ) {
                        atBreakpoint = true;
                    }
                }
            } );
        }
        return atBreakpoint;
    },
    getTrigger: function( $target ) {
        var toggleID, $trigger;
        if ( typeof $target !== "undefined" ) {
            toggleID = $target.attr( "id" );
            if ( typeof toggleID !== "undefined" && toggleID !== "" ) {
                $trigger = $( "[" + this.attr.toggleID + "=" + toggleID + "]", context );
            } else {
                $trigger = $target.prev();
            }
        }
        return $trigger;
    },
    getTarget: function( $trigger ) {
        var toggleID, $target;
        if ( typeof $trigger !== "undefined" ) {
            toggleID = $trigger.attr( this.attr.toggleID );
            if ( typeof toggleID !== "undefined" && toggleID !== "" ) {
                $target = $( "#" + toggleID, context );
            } else {
                $target = $trigger.siblings( "[" + this.attr.toggleTarget + "]" );
            }
        }
        return $target;
    },
    reveal: function( $trigger ) {
        var that = this,
            action = false;
        this.getTarget( $trigger ).each( function( idx, el ) {
            // Update state attributes on target and trigger elements
            $( el ).slideDown( "fast" ).attr( that.attr.state, "open" );
            $trigger.attr( that.attr.state, "open" );
            // If the trigger has an alignment attribute, call the align function
            if ( ( typeof $trigger.attr( that.attr.align ) !== "undefined" &&
                    $trigger.attr( that.attr.align ) !== "" ) ||
                $trigger.has( "[" + that.attr.align + "]" ).length > 0 ) {
                rh.webux.alignElement.init( $trigger );
            }
            action = true;
        } );
        return action;
    },
    hide: function( $trigger ) {
        var that = this,
            action = false,
            $target;
        this.getTarget( $trigger ).each( function( idx, el ) {
            $target = $( el );
            if ( $target.attr( that.attr.state ) !== "closed" ) {
                // Update state attributes on target and trigger elements
                $target.slideUp( "fast" ).attr( that.attr.state, "closed" );
                $trigger.attr( that.attr.state, "closed" );
                action = true;
            }
        } );
        return action;
    },
    element: function( $trigger, change ) {
        var that = this,
            bpTargets,
            state, action = false;
        this.getTarget( $trigger ).each( function( idx, el ) {
            state = $trigger.attr( that.attr.state );
            bpTargets = $( el ).attr( that.attr.toggleTarget );
            // If we are approved to toggle
            if ( that.isAtBreakpoint( bpTargets ) || bpTargets === "" ) {
                /* If the state is closed, an empty string,
                or the attribute does not exist, slide down */
                if ( state === "closed" || state === "" ||
                    state === "undefined" || typeof state === "undefined" ) {
                    if ( change ) {
                        action = that.reveal( $trigger ) ? true : action;
                    } else {
                        action = that.hide( $trigger ) ? true : action;
                    }
                } else {
                    if ( change ) {
                        action = that.hide( $trigger ) ? true : action;
                    } else {
                        action = that.reveal( $trigger ) ? true : action;
                    }
                }
            }
        } );
        return action;
    },
    reset: function( $trigger ) {
        var that = this,
            targetBps;
        this.getTarget( $trigger ).each( function( idx, el ) {
            targetBps = $( el ).attr( that.attr.toggleTarget );
            // If not an allowed breakpoint, remove attribute settings
            if ( that.isAtBreakpoint( targetBps ) || targetBps === "" ) {
                that.element( $trigger, false );
            } else if ( $( el ).attr( that.attr.state ) === "closed" ) {
                that.reveal( $trigger );
            }
        } );
    },
    event: function( $trigger, singleTrigger ) {
        var that = this,
            delay = 0,
            hide;
        if ( singleTrigger ) {
            hide = false;
            // Hide sibling elements
            $trigger.siblings( "[" + that.attr.openEvent + "]" ).each( function( idx, el ) {
                hide = that.hide( $( el ) ) ? true : hide;
            } );
            // If any of the siblings have been hidden, add a delay to the UI
            if ( hide ) {
                delay = 200;
            }
            setTimeout( function() {
                that.element( $trigger, true );
            }, delay );
        } else {
            that.element( $trigger, true );
        }
    }
};

/* On load, trigger the closing of any open accordions
    that have a state of closed set and attach click event */

$( "[" + rh.webux.toggle.attr.openEvent + "=hover], [" + rh.webux.toggle.attr.openEvent + "=click]",
    context ).each( function( idx, val ) {
    var $val = $( val ),
        toggleID = $val.attr( rh.webux.toggle.attr.toggleID ),
        eventType = $val.attr( rh.webux.toggle.attr.openEvent ),
        singleTrigger = false;

    // Find out if this element is wrapped in a single toggle attribute
    if ( $val.closest( "[" + rh.webux.toggle.attr.toggleSingle + "]" ).length > 0 ) {
        singleTrigger = true;
    }

    // OnLoad activate current state based on data attribute
    rh.webux.toggle.element( $val, false );
    if ( eventType === "click" ) {
        // OnClick change current state and data attribute
        $val.click( function() {
            rh.webux.toggle.event( $val, singleTrigger );
        } );
    } else if ( eventType === "hover" ) {
        // OnHover change current state and data attribute
        $val.hover( function() {
            rh.webux.toggle.event( $val, singleTrigger );
        } );
    }
} );

/* Trigger the closing by clicking inside the target element */
$( "[" + rh.webux.toggle.attr.closeEvent + "=click]", context ).each( function( idx, val ) {
    var $val = $( val ),
        toggleID = $val.attr( rh.webux.toggle.attr.toggleID );
    // OnClick change current state and data attribute
    rh.webux.toggle.getTarget( $val ).click( function() {
        rh.webux.toggle.element( $val, true );
    } );
} );

// Create debounce function to only trigger calls one time after it finishes resizing,
// instead of hundreds of times while it is updated
$( window ).on( "resize", function() {
    clearTimeout( resizeTimer );
    var that = rh.webux.toggle,
        resizeTimer = setTimeout( function() {
            // Reset any element that have been triggered before resizing and need to be reset.
            $( "[" + that.attr.openEvent + "=hover],[" + that.attr.openEvent + "=click]", context )
                .each( function( idx, val ) {
                    var $val = $( val ),
                        toggleID = $val.attr( that.attr.toggleID );
                    if ( typeof toggleID !== "undefined" && toggleID !== "" ) {
                        that.reset( $val );
                    } else {
                        that.reset( $val );
                    }
                } );
        }, 200 );
} );

// Theme Toggle for Cards
rh.webux.themeToggle = function( target, type, event ) {
    var $target = $( target ),
        attr     = "data-ux-" + type,
        selector = "data-ux-" + type + "-" + event,
        currentType = $target.attr( attr ),
        newType = $target.attr( selector );

    $target.attr( attr, newType );
    $target.attr( selector, currentType );
};

$.each( [ "theme", "background" ], function( idx, type ) {
    $( "[data-ux-" + type + "-hover]", context ).hover( function() {
        rh.webux.themeToggle( this, type, "hover" );
    } );

    $( "[data-ux-" + type + "-click]", context ).click( function() {
        rh.webux.themeToggle( this, type, "click" );
    } );
} );

rh.webux.animation = {
    attr: {
        fireEvent: "data-ux-animation-trigger",
        name: "data-ux-animation-name",
        timing: "data-ux-animation-timing",
        trigger: "data-ux-animation-id",
        target: "data-ux-animation-target",
        styles: "data-ux-animate"
    },
    getTarget: function( $trigger ) {
        var id, $targets;
        if ( typeof $trigger !== "undefined" ) {
            id = $trigger.attr( this.attr.trigger );
            if ( typeof id !== "undefined" && id !== "" ) {
                $targets = $( "[" + this.attr.target + "=" + id + "]", context );
            }
        }
        return $targets;
    },
    animate: function( $el, name, timing ) {
        var that = this,
            animationTimer;
        // Trigger animation
        $el.attr( this.attr.styles, name );
        animationTimer = setTimeout( function() {
            $el.removeAttr( that.attr.styles );
        }, timing );
    },
    event: function( $trigger ) {
        var that = this;
        // Get the target elements and fire the animation status
        var timing = parseInt( $trigger.attr( this.attr.timing ) ),
            name = $trigger.attr( this.attr.name ),
            $targets = this.getTarget( $trigger );
        // If the timing is not set or is not a valid number, default to 300ms
        if ( isNaN( timing ) ) {
            timing = 300;
        }
        if ( typeof $targets !== "undefined" ) {
            $targets.each( function( idx, el ) {
                that.animate( $( el ), name, timing );
            } );
        } else {
            this.animate( $trigger, name, timing );
        }
    }
};

/* On click or hover, trigger the animation event */
$( "[" + rh.webux.animation.attr.fireEvent + "=hover]," +
    " [" + rh.webux.animation.attr.fireEvent + "=click]",
    context ).each( function( idx, val ) {
    var $val = $( val ),
        eventType = $val.attr( rh.webux.animation.attr.fireEvent );

    if ( eventType === "click" ) {
        // OnClick change current state and data attribute
        $val.click( function() {
            rh.webux.animation.event( $val );
        } );
    } else if ( eventType === "hover" ) {
        // OnHover change current state and data attribute
        $val.mouseenter( function() {
            rh.webux.animation.event( $val );
        } );
    }
} );

// Supports tab interactions and direct linking to tabset
// -- Global helper functions

// Attach a string toggle function for use on elements
if ( typeof String.prototype.toggleString == "undefined" ) {
    String.prototype.toggleString = function( string1, string2 ) {
        return ( String( this ) === string1 ) ? string2 : string1;
    };
}

// CUSTOM JS to convert query string to JSON obj
if ( typeof rh.webux.queryToJSON == "undefined" ) {
    rh.webux.queryToJSON = function( input ) {
        var sets = {},
            search = ( typeof input === "undefined" ) ? location.search : input,
            array = ( typeof search != "undefined" ) ? search.slice( 1 ).split( "&" ) : [ "" ];
        $.each( array.filter( function( n ) {
            return n !== "";
        } ), function( idx, val ) {
            var group = val.split( "=" );
            sets[ group[ 0 ] ] = decodeURIComponent( group[ 1 ] || "" );
        } );
        return JSON.parse( JSON.stringify( sets ) );
    };
}

// Supports tab interactions and direct linking to tabset
if ( typeof rh.webux.hash == "undefined" ) {
    rh.webux.hash = function( location ) {
        // Default to window.location
        location = location || window.location;
        return location.hash.replace( /^#/, "" ).split( "." );
    };
}

// Get the height of a hidden or potentially hidden element
if ( typeof rh.webux.getTrueHeight == "undefined" ) {
    rh.webux.getTrueHeight = function( $el ) {
        // Copy element, hide, set height auto and copy current width
        var $copy = $el.clone().css( {
                "display": "block",
                "position": "absolute",
                "top": "-999px",
                "left": "-999px",
                "height": "auto",
                "minHeight": "auto",
                "maxHeight": "auto",
                "width": $el.outerWidth() + "px"
            } ).appendTo( "body" ),
            // Get the height of the clone element
            height = $copy.outerHeight();
        // Remove the cloned element
        $copy.remove();
        return height;
    };
}

//--- Global utility variables
rh.webux.utils = {
    lg: function() {
        return $( window ).width() >= 1200;
    },
    md: function() {
        return $( window ).width() >= 992 && $( window ).width() < 1200;
    },
    sm: function() {
        return $( window ).width() >= 768 && $( window ).width() < 992;
    },
    xs: function() {
        return $( window ).width() >= 480 && $( window ).width() < 768;
    },
    xxs: function() {
        return $( window ).width() < 480;
    },
    isDesktop: $( window ).width >= 768,
    isTablet: $( window ).width >= 480 && $( window ).width < 768,
    isMobile: $( window ).width < 480,
    breakpoints: [ "xxs", "xs", "sm", "md", "lg" ],
    url: {
        root: window.location.hostname,
        path: window.location.pathname.split( "/" ).splice( 1 )
    },
    lang:   window.location.pathname.split( "/" ).splice( 1 )[ 0 ]
};


rh.webux.tab = {
    check:  function( split ) {
        if ( split[ 0 ] === "tab" ) {
            this.switch( split[ 1 ], split[ 2 ] );
        }
    },
    switch: function( id, index ) {
        if ( typeof id !== "undefined" ) {
            $( "[data-ux-tab-id='"  + id +  "']" ).each( function( i, v ) {
                var $children = $( v ).children();
                $children.attr( "data-ux-active", "false" );
                if ( typeof index !== "undefined" ) {
                    $children.eq( index ).attr( "data-ux-active", "true" );
                }
            } );
        }
    }
};

// When the hash changes, check for a tab change
$( window ).bind( "hashchange", function() {
    rh.webux.tab.check( rh.webux.hash( location ) );
} );

// On load, if a url hash exists, run a tab check
if ( window.location.hash ) {
    rh.webux.tab.check( rh.webux.hash() );
}

/**
* Manages the accordion open/closed states
*
* Object literal containing 1 function: click(), which takes 2 inputs:
* - the element clicked
* - a string of the class name for the content container
*/

// Include the helpers tools so that the toggleString function is available
// -- Global helper functions

// Attach a string toggle function for use on elements
if ( typeof String.prototype.toggleString == "undefined" ) {
    String.prototype.toggleString = function( string1, string2 ) {
        return ( String( this ) === string1 ) ? string2 : string1;
    };
}

// CUSTOM JS to convert query string to JSON obj
if ( typeof rh.webux.queryToJSON == "undefined" ) {
    rh.webux.queryToJSON = function( input ) {
        var sets = {},
            search = ( typeof input === "undefined" ) ? location.search : input,
            array = ( typeof search != "undefined" ) ? search.slice( 1 ).split( "&" ) : [ "" ];
        $.each( array.filter( function( n ) {
            return n !== "";
        } ), function( idx, val ) {
            var group = val.split( "=" );
            sets[ group[ 0 ] ] = decodeURIComponent( group[ 1 ] || "" );
        } );
        return JSON.parse( JSON.stringify( sets ) );
    };
}

// Supports tab interactions and direct linking to tabset
if ( typeof rh.webux.hash == "undefined" ) {
    rh.webux.hash = function( location ) {
        // Default to window.location
        location = location || window.location;
        return location.hash.replace( /^#/, "" ).split( "." );
    };
}

// Get the height of a hidden or potentially hidden element
if ( typeof rh.webux.getTrueHeight == "undefined" ) {
    rh.webux.getTrueHeight = function( $el ) {
        // Copy element, hide, set height auto and copy current width
        var $copy = $el.clone().css( {
                "display": "block",
                "position": "absolute",
                "top": "-999px",
                "left": "-999px",
                "height": "auto",
                "minHeight": "auto",
                "maxHeight": "auto",
                "width": $el.outerWidth() + "px"
            } ).appendTo( "body" ),
            // Get the height of the clone element
            height = $copy.outerHeight();
        // Remove the cloned element
        $copy.remove();
        return height;
    };
}


rh.webux.accordion = {
    click: function( el, content ) {
        var $parent = $( el ),
            state = $parent.attr( "data-ux-state" ) || "";
        // Toggle content area open or closed
        $parent.children( content ).slideToggle( ".3s" );
        // Update the state
        $parent.attr(
            "data-ux-state",
            state.toggleString( "open", "closed" )
        );
    }
};

/**
* Progressive enhancement approach:
* For each accordion item that is not already open,
* find the content for that item and hide it
*/
$( ".ux-accordion-item:not([data-ux-state=open])", context ).each( function( key, val ) {
    $( val ).find( ".ux-accordion-content" ).hide();
} );

/**
* Attach the click function to the
* onclick event for the accordion item
*/
$.each( rh.webux.accordion, function( evt, func ) {
    $( ".ux-accordion-item", context ).on( evt, function() {
        func( this, ".ux-accordion-content" );
    } );
} );


try {
    $( ".popup-youtube, .popup-vimeo, .popup-gmaps" ).magnificPopup( {
        disableOn: 0,
        type: "iframe",
        mainClass: "mfp-fade",
        removalDelay: 160,
        preloader: false,
        fixedContentPos: false
    } );
}
catch ( err ) {
    // Comment the console.log so it doesn't show errors on pages that don't load magnific.
    // console.log("Magnific popup not loaded or throwing an error: " + err);
}
        }
    };
} )( window, jQuery, ( "undefined" == typeof rh ) ? {} : rh );
l ‚šò      ]Y]Z@Ùój]ÞØ   ;    :https://www.redhat.com/files/webux/js/homepage/homepage.js necko:classified 1 strongly-framed 1 security-info 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 request-method GET response-head HTTP/2.0 200 OK
x-amz-id-2: HvBCfmfwhFstaslVLc9CDyZ7S3LprPhFxdDVDZk8exkNpKG7o/N8V8ASbS9/BMAlSZUrt4uhh20=
x-amz-request-id: 4300ED467038E24C
last-modified: Thu, 08 Aug 2019 18:38:18 GMT
etag: "20e8b168ff028b59a9642cd36106f954"
accept-ranges: bytes
content-type: application/javascript
content-length: 20491
server: AmazonS3
cache-control: max-age=86400
expires: Sun, 29 Sep 2019 16:42:01 GMT
date: Sat, 28 Sep 2019 16:42:01 GMT
X-Firefox-Spdy: h2
 original-response-headers x-amz-id-2: HvBCfmfwhFstaslVLc9CDyZ7S3LprPhFxdDVDZk8exkNpKG7o/N8V8ASbS9/BMAlSZUrt4uhh20=
x-amz-request-id: 4300ED467038E24C
last-modified: Thu, 08 Aug 2019 18:38:18 GMT
etag: "20e8b168ff028b59a9642cd36106f954"
accept-ranges: bytes
content-type: application/javascript
content-length: 20491
server: AmazonS3
cache-control: max-age=86400
expires: Sun, 29 Sep 2019 16:42:01 GMT
date: Sat, 28 Sep 2019 16:42:01 GMT
X-Firefox-Spdy: h2
 ctid 2 eTLD1Access 1;0;3423907821, uncompressed-len 0 net-response-time-onstart 1470 net-response-time-onstop 1471   P